import random
import numpy as np
from tree import SVTree


class SVRegressor:
    """
    A class for running a genetic algorithm to perform symbolic
    regression using structure vectors.

    Attributes:

        settings (Settings):
            The settings used during regression. Use
            Settings.printValidSettings() to see valid settings options and
            suggested values.

        svNodePool (list):
            A list of SVNode objects representing the different types of SVs
            to be used during the regression.

        optimizer (object):
            The constructor for an optimizer object that will be used to
            optimize tree parameters. It is assumed that `optimizer` is a
            population-based optimizer and that it implements an ask() and
            tell() interface. An optimizer instance will be generated by calling
            optimizer(tree.populate(N=1)[0], **optimizerArgs) for tree in
            self.trees.

        optimizerArgs (dict):
            A dictionary of named arguments to be passed to the tree optimizers.

        trees (list):
            A list of SVTree objects being optimized.
    """

    def __init__(
            self,
            settings,
            svNodePool,
            optimizer=None,
            optimizerArgs=None,
        ):

        # Note: it is assumed that Settings has already performed all validation
        # checks on the provided settings.

        self.settings = settings
        self.svNodePool = svNodePool

        self.optimizer = optimizer

        self.optimizerArgs = optimizerArgs
        if self.optimizerArgs is None:
            self.optimizerArgs = {}

        self.trees = []


    def initializeTrees(self, singleNodeTreeProb=0.1):
        """Populates the GA with randomly-generated equation trees."""

        self.trees = [
            SVTree.random(
                svNodePool=self.svNodePool,
                maxDepth=random.randint(1, self.settings['maxTreeDepth']),
            ) for _ in range(self.settings['numberOfTrees'])
        ]

    
    def populateTrees(self, N):
        """
        Returns a list of populations for the trees. Note that they can't be
        stacked because the each tree's population may have a different shape.

        # TODO: rename? I don't think trees actually need to save their pops.
        # TODO: also rename tree.populate()

        # TODO: I think this function is obsolete. Optimizers should generate.
        """

        treePopulations = {}
        for tree in self.trees:
            # Each tree returns {svName: population}
            treePop = tree.populate(N)

            # Combine into full dictionary
            for svName in treePop:
                if svName in treePopulations:
                    treePopulations[svName].append(treePop)
        
        # Stack the populations for batch evaluation
        for svName in treePopulations:
            treePopulations[svName] = np.vstack(treePopulations[svName])

        return treePopulations


    def evaluateTrees(self, values, N):
        """
        Updates the SVNode objects in the trees with the given values, then
        evaluate the trees

        Args:
            values (dict):
                {structName: {svName: list of values for each tree}}

            N (int):
                The number of parameter sets for each node. Used for splitting
                the population of results.

        Return:
            results (dict):
                {structName: [tree.eval() for tree in self.trees]}
        """

        results = {struct:[] for struct in values.keys()}
        for structName in values:
            for svName in values[structName]:
                # The list of stacked values for each tree for a given SV type
                listOfValues = values[structName][svName]

                # Un-stack any stacked values
                unstackedValues = []
                for val in listOfValues:
                    unstackedValues += np.split(val, val.shape[0]//N, axis=0)

                # Loop over the list of values
                # for tree, treeVals in zip(self.trees, listOfValues):
                for tree in self.trees:
                    # Each node has the same population size, so just split
                    # splitValues = np.split(treeVals, N)
                    for svNode in tree.svNodes:
                        # Only update the SVNode objects of the current type
                        if svNode.description == svName:
                            # svNode.values = splitValues.pop()
                            svNode.values = unstackedValues.pop()

                # Error check to see if there are leftovers
                leftovers = len(unstackedValues)
                if leftovers > 0:
                    raise RuntimeError('Found leftover results.')

            # If here, all of the nodes have been updated with their values
            for tree in self.trees:
                results[structName].append(tree.eval())

        return results


    def initializeOptimizers(self):
        self.optimizers = [
            self.optimizer(
                tree.populate(N=1)[0],
                *self.optimizerArgs
            )
            for tree in self.trees
        ]


    def mate(self):
        raise NotImplementedError

    
    def mutate(self):
        raise NotImplementedError
